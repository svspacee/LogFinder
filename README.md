# LogFinder
Написать программу для поиска заданного текста в лог файлах.

Пользователь должен иметь возможность указать папку в сети или на жестком диске, в которой будет
происходить поиск заданного текста, включая все вложенные папки.
Должна быть возможность ввода текста поиска и ввода типа расширения файлов, в которых будет
осуществляться поиск(расширение по умолчанию *.log).
Результаты поиска можно вывести в левой части приложения в виде дерева файловой системы
только те файлы в которых был обнаружен заданный текст.
В правой части приложения выводить содержимое файла с возможностью навигации по найденному
тексту (выделить все, вперед/назад).
Плюсом будет многопоточность приложения, «не замораживание» приложения на время поиска,
возможность открывать «большие» (более 1Г) файлы и осуществлять по ним быструю навигацию,
возможность открывать файлы в новых «табах», т. е. использовать TabFolder или MDI.
Для отображения разрешается использовать любые Java GUI-фреймворки (AWT, Swing, SWT, JavaFX,
NetBeans Platform и т.п.).
Приложение может быть как десктопным, так и веб-клиентом.

## Описание
### Использованные технологии
* JavaFx, каркас GUI представлен fxml-файлом, некоторые элементы устанавливаются динамически;
* Jfoenix -  библиотека со стилизированными под material design элементами gui;
* Maven;
* Junit 4 для тестирования различных подходов аналаза файлов;
* JProfiler для отслеживания расхода памяти при работе с файлами;

### Реализация, проблемы и их решения (и не очень)
> Для анализа файлов выбором стал Stream API

При выборе способа анализа файла рассматривалось много вариантов: от Scanner до RandomAccessFile.
После проведенных тестов над файлами размером от 1GB с заданным для поиска текстом в самом конце, BufferedInputStream 
и Stream API оказались быстрее всех, но при этом второй во многих случаях оказывался в два раза быстрее первого и при этом
идеалогия stream api позволила написать гораздо меньше кода, что повысило его читаемость.

> Проблема: чем ближе к концу файла заданный текст, тем медленнее будет его выявление. 

Попытка решения: использование RandomAccessFile и алгоритма двух указателей - просматриваем файл с обеих сторон до тех
пор, пока указатели не сойдутся. Как итог: моментальное выявление текста в начале или конце и огромные проседания по 
производительности если файл находится в середине и, в среднем, сильное отставание как от stream-ов, так и от bis.

>Проблема: OutOfMemory при размере файла уже в 150 мегабайт

TextArea в javafx плохо работает с больши количеством текста, поэтому использовался гибридный подход: если в 
файле меньше заданного колличества строк, то используется TextArea и обеспечивает стабильную навигацию по файлу,  
если количество строк выше этой границы, файл открывается в постраничном виде (по 60 строк на одну страницу). Pagination успешно справляется 
с файлами, которые textArea уже не могла загрузить, однако не без проблем:
в очень больших файлах с огромным колличеством строк (~40 млн), чем ближе к последней странице, тем 
ощутимо дольше страница будет открываться.

> Поддержка множества вкладок

Для открытия файла в новой вкладке установлена специальная кнопка в нижнем баре. Для закрытия вкладки просто кликнуть
на нее дважды :)

 > Все операции происходят в многопоточном режиме

Такие операции как поиск файлов в директории, открытие файла в основном окне и открытие в новой вкладке не замораживают
GUI, однако вручную добавлено отключение некоторых функций на время операций (например, если вы уже открыли файл и процесс
открытия не завершен, приложение не позволит выбрать новый). Открывая файл в новой вкладки или начав новый поиск, можно
спокойно дальше просматривать уже открытый файл. Процесс выполнения какой-то операции в фоне сопровождается индикатором.

Использовался javafx.concurrent.Task

### Разработка и тестирование
- Windows 10;
- Intellij IDEA;
- intel core i5 8U;
- 8 gb ram;
- ssd 3000 mb / 2000 mb read/write

